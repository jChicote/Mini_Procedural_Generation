// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct MeshPoint 
{
    float3 vert;
    float3 normal;
    float2 uv;
};

struct QuadTrisSet 
{
    float3 triangleA;
    float3 triangleB;
};

RWStructuredBuffer<float> noiseData;
RWStructuredBuffer<float3> vertices;
RWStructuredBuffer<float3> normal;
RWStructuredBuffer<float2> uv;
RWStructuredBuffer<QuadTrisSet> triangles;

float resolution;
float maxHeight;
float meshSize;

int meshLineSize;

float CalculateHeight(float noiseVal) {
    return noiseVal * maxHeight;
}

int CalculateRow(int index) {
    float row = floor(index / meshSize);
    return int(row);
}

int CalculateColumn(int index, int row) {
    return index - row * meshSize;
}

// Verticies are added in a clockwise direction for each
// triangle pair in quad.
float3 AddTriangle(int vertA, int vertB, int vertC) {
    float3 triangleIndexes = float3(0, 0, 0);
    triangleIndexes.x = vertA;
    triangleIndexes.y = vertB;
    triangleIndexes.z = vertC;
    return triangleIndexes;
}

[numthreads(64, 1, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint index = id.x;
    int row = CalculateRow(index);
    int col = CalculateColumn(index, row);

    QuadTrisSet tris = triangles[index];
    /*MeshPoint meshPoint = meshPoints[index];
    meshPoint.vert.y = CalculateHeight(noiseData[index]);*/

    vertices[index].y = CalculateHeight(noiseData[index]);
    normal[index] = float3(0, 0, -1);
    uv[index] = float2(col, row);

    if (col < meshSize - 1 && row < meshSize - 1) {
        tris.triangleA = AddTriangle(index, index + meshLineSize, index + 1);
        tris.triangleB = AddTriangle(index + 1, index + meshLineSize, index + meshLineSize + 1);
        triangles[index] = tris;
    }
}
