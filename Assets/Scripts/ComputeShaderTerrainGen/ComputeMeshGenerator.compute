#pragma kernel CSMain


// Data Array Buffers 
RWStructuredBuffer<int> triangles;
RWStructuredBuffer<float> noiseData;
RWStructuredBuffer<float3> vertices;
RWStructuredBuffer<float3> normal;
RWStructuredBuffer<float2> uv;

float resolution;
float maxHeight;
float minHeight;
float meshSize; // Constant

int meshLineSize;
int incrementStep;

float CalculateHeight(float noiseVal) {
    float height = noiseVal * maxHeight;
    return clamp(height, minHeight, maxHeight);
}

float3 CalculateVertexPosition(int row, int col) {
    float3 vertPos = float3(0, 0, 0);
    vertPos.x = col;
    vertPos.y = CalculateHeight(noiseData[row * meshSize + col]);
    vertPos.z = row;
    return vertPos;
}

int CalculateRow(uint index) {
    float row = floor(index / meshLineSize);
    return int(row);
}

int CalculateColumn(int index, int row) {
    return index - (row * meshLineSize);
}

// summary:
//  - Calculates offset to the array accounting for skips in quads 
//    made after each row is processed (6 from each row).
//
// returns:
//  - Quad offset to mesh.
int CalculateOffset(int row, int col) {
    if (row == 0) {
        return 0;
    }

    int arrayOffset = (row) * 6;
    return arrayOffset;
}


void AddQuad(int index, int offset) {
    int stepIndex = index * 6 - offset;
    triangles[stepIndex] = index;
    triangles[stepIndex + 1] = index + meshLineSize;
    triangles[stepIndex + 2] = index + 1;
    triangles[stepIndex + 3] = index + 1;
    triangles[stepIndex + 4] = index + meshLineSize;
    triangles[stepIndex + 5] = (index + meshLineSize) + 1;
}

// -------------------------------------------------------
//                           Main 
// -------------------------------------------------------

[numthreads(64, 1, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint index = id.x;
    int row = CalculateRow(index);
    int col = CalculateColumn(index, row);

    int scaledRow = row * (meshSize / meshLineSize);
    int scaledCol = col * incrementStep;

    vertices[index] = CalculateVertexPosition(scaledRow, scaledCol);
    normal[index] = float3(0, 0, 1);
    uv[index] = float2(scaledCol, scaledRow);

    if (col < meshLineSize - 1 && row < meshLineSize  - 1) {
        AddQuad(index, CalculateOffset(row, col));
    }
    /*

    if (scaledCol < meshSize - 1 && scaledRow < meshSize - 1) {
        AddQuad(index);
    }*/
}
